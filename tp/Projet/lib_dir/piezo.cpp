//==========================================================================================================//
//PLEASE READ THE FOLLOWING
//==========================================================================================================//

//The piezo needs to be plugged in onto the pins. It requires 2 pins. 1 pin gets the PWM output and 1 gets the ground

//There are two timer/counters in the atmega324pa

//We will be using one for this music generation. We will use the timer/counter 1

//They each have OCxA/B pins that are the output of the PWM generated by them
//The important part here is to understand their location depending on which ones you want.

//Piezo OCxA/OCxB pin locations	

//(PCINT28/XCK1/OC1B) 		PD4 
//(PCINT29/OC1A) 			PD5 

//What you pass in the piezo_init function is the value these macros represent (aka pin positions)
//This basically says you want the PWM to be generated on (if we go with the motherboard's notation)
//port D's pin 5 and pin 6

//==========================================================================================================//

#include "piezo.h"

static uint8_t setup_value; 

/*****************************************************************************
*
*   Function name : piezo_init
*
*   Returns :       void
*
*   Parameters :    uint8_t pwm_pin -> possible values: {DDD4, DDD5} or any macro that replace to the same values! such as PD4 and PD5
					uint8_t ground_pin -> possible values: {if pwm_pin == DDD4 : { DDD2, DDD5, DDD6 } else if pwm_pin == DDD5 : { DDD3,DDD4,DDD7 }}
					uint8_t volume -> possible values: {0, 1, 2, ..., 100}
*
*   Purpose :       Set the timer/counter registers for the music pwm
*
*****************************************************************************/
void piezoInit(uint8_t pwm_pin, uint8_t ground_pin, uint8_t volume){
	setup_value = pwm_pin;
	switch(setup_value){
   		case DDD4: 
			DDRD |= _BV(pwm_pin); //OC1B as output
			TCCR1A |= _BV(COM1B1); //Clear 
			OCR1B = volume;
   		    break;
   		case DDD5:
			DDRD |= _BV(pwm_pin); //OC1A as output
			TCCR1A = _BV(COM1A1);
			OCR1A = volume;
   		    break;
   		default:
   			//silently fail if DEBUG mode is off
   			DEBUG_ERROR();
	}
	DDRD |= _BV(ground_pin);
	TCCR1B |= _BV(WGM13) 	//PWM, Phase and Frequency Correct (TOP value is ICR1)
	   	   |  _BV(CS11);	//8 prescaler
}


/*****************************************************************************
*
*   Function name : setVolume
*
*   Returns :       void
*
*   Parameters :    uint8_t volume -> possible values: {0, 1, 2, ..., 100}
*
*   Purpose :       Set the volume. More accurately... this sets the duty cycle.
*					Setting the duty cycle should yield in different sound, yet
*					it reduces the volume. Might have been fed misleading info.
*
*****************************************************************************/
void setVolume(uint8_t volume){
	switch(setup_value){
   		case DDD4: 
			OCR1B = volume;
   		    break;
   		case DDD5:
			OCR1A = volume;
   		    break;
	}
}

/*****************************************************************************
*
*   Function name : playNote
*
*   Returns :       void
*
*   Parameters :    uint8_t duration_in_ms -> possible values: {0, 1, 2, ..., 65535}
*					uint8_t note  -> possible values: {45, 46, 47, ..., 81}
*
*   Purpose :       Set the timer/counter registers for the music pwm
*
*****************************************************************************/

void playNote(uint8_t midi_key, uint16_t duration_in_ms){
	unsigned char sreg;
	sreg = SREG;
	cli();
	ICR1H = (note[midi_key] >> 8); //first set the high byte
	ICR1L = note[midi_key];        //now the low byte
	SREG = sreg;
	variableDelay(duration_in_ms);
}